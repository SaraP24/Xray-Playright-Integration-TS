"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setXrayMetadata = void 0;
const picocolors_1 = require("picocolors");
const convert_1 = require("./convert");
const help_1 = __importDefault(require("./help"));
const xray_service_1 = require("./xray.service");
class XrayReporter {
    constructor(options) {
        this.testCaseKeyPattern = /^(.+?) \| /;
        this.receivedRegEx = /Received string: "(.*?)"(?=\n)/;
        this.defaultRunName = `[${new Date().toUTCString()}] - Automated run`;
        this.stepCategories = ['expect', 'pw:api', 'test.step'];
        this.options = options;
        this.help = new help_1.default(this.options.jira.type);
        this.xrayService = new xray_service_1.XrayService(this.options);
        this.totalDuration = 0;
        this.uploadScreenShot = options.uploadScreenShot;
        this.uploadTrace = options.uploadTrace;
        this.uploadVideo = options.uploadVideo;
        this.stepCategories = options.stepCategories === undefined ? this.stepCategories : options.stepCategories;
        this.testsByKey = new Map();
        this.testResults = {
            testExecutionKey: this.options.testExecution,
            info: {
                summary: this.defaultRunName,
                project: this.options.projectKey,
                startDate: this.help.getFormatData(new Date()),
                finishDate: this.help.getFormatData(new Date()),
                testPlanKey: this.options.testPlan,
                revision: this.options.revision,
                description: this.options.description,
                testEnvironments: this.options.testEnvironments,
                version: this.options.version,
            },
            tests: [],
        };
        this.projectsToExclude = this.options.projectsToExclude;
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.blue)('-------------------------------------'))}`);
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.blue)(' '))}`);
        if (this.options.summary !== undefined)
            this.testResults.info.summary = this.options.summary;
        this.execInfo = {
            browserName: '',
            testedBrowser: undefined,
        };
    }
    async onBegin(config, suite) {
        try {
            this.setProjectToReport(suite, config);
        }
        catch (error) {
            throw new Error(`Failed to obtain project with error: ${error}`);
        }
        if (this.options.dryRun) {
            console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)('⏺  '))}${(0, picocolors_1.bold)((0, picocolors_1.blue)(`Starting a Dry Run with ${suite.allTests().length} tests`))}`);
        }
        else {
            console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)('⏺  '))}${(0, picocolors_1.bold)((0, picocolors_1.blue)(`Starting the run with ${suite.allTests().length} tests`))}`);
        }
        console.log(`${(0, picocolors_1.bold)((0, picocolors_1.blue)(' '))}`);
        if (this.execInfo.testedBrowser !== undefined) {
            console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)('⏺  '))}${(0, picocolors_1.bold)((0, picocolors_1.blue)(`The following test execution will be imported & reported:  ${this.execInfo.testedBrowser}`))}`);
        }
    }
    async onTestBegin(_test) {
        if (this.execInfo.testedBrowser === undefined) {
            console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)('⏺  '))}${(0, picocolors_1.bold)((0, picocolors_1.red)('No projects to run, have you excluded all in your playwright config?'))}`);
            return;
        }
    }
    async onTestEnd(testCase, result) {
        const testCaseId = testCase.title.match(this.testCaseKeyPattern);
        const testCode = testCaseId?.[1] ?? '';
        const projectId = JSON.stringify(testCase.parent.project()).match(/__projectId":"(.*)"/)?.[1];
        if (this.execInfo.testedBrowser !== projectId) {
            return;
        }
        if (testCode !== '') {
            const tests = this.testsByKey.get(testCode);
            if (!tests) {
                this.testsByKey.set(testCode, [result]);
            }
            else {
                tests.push(result);
            }
            let projectID = '';
            const tst = JSON.stringify(testCase.parent.project()).match(/__projectIdd":"(.*)"/)?.[1];
            if (tst !== undefined) {
                projectID = `${tst.charAt(0).toUpperCase() + tst.slice(1)} | `;
            }
            switch (this.help.convertPwStatusToXray(result.status)) {
                case 'PASS':
                case 'PASSED':
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.green)(`✅ ${projectID}${testCase.title}`))}`);
                    break;
                case 'FAIL':
                case 'FAILED':
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.red)(`⛔ ${projectID}${testCase.title}`))}`);
                    break;
                case 'SKIPPED':
                case 'ABORTED':
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.white)(`🚫 ${projectID}${testCase.title}`))}`);
                    break;
            }
        }
    }
    async onEnd() {
        // Update test Duration
        this.testResults.info.finishDate = this.help.getFormatData(new Date(new Date(this.testResults?.info?.startDate ?? new Date()).getTime() + this.totalDuration));
        this.testResults.tests = await (0, convert_1.convertToXrayJson)(this.testsByKey, {
            receivedRegEx: this.receivedRegEx,
            stepCategories: this.stepCategories,
            uploadScreenshot: this.uploadScreenShot,
            uploadTrace: this.uploadTrace,
            uploadVideo: this.uploadVideo,
            jiraType: this.options.jira.type,
            jiraXrayStatusMapping: this.options.jiraXrayStatusMapping,
        });
        if (typeof this.testResults !== 'undefined' && typeof this.testResults.tests !== 'undefined' && this.testResults.tests.length > 0) {
            await this.xrayService.createRun(this.testResults, this.execInfo);
        }
        else {
            console.log(`There are no tests with such ${this.testCaseKeyPattern} key pattern`);
        }
    }
    // biome-ignore lint/complexity/noBannedTypes: Allow for {}
    setProjectToReport(suite, config) {
        const projectsToReport = [];
        // biome-ignore lint/suspicious/noExplicitAny: Allow for any
        const entries = suite._entries;
        const cliArguments = entries.flatMap((o) => o._fullProject.fullConfig.cliProjectFilter);
        if (cliArguments !== undefined && cliArguments[0] !== undefined) {
            projectsToReport.push(cliArguments[0]);
        }
        // Exclude projects from the report
        // If the projectsToExclude is an array, we will use the regex to exclude the projects
        if (this.projectsToExclude !== undefined && typeof this.projectsToExclude !== 'string' && this.projectsToExclude.length > 1) {
            this.removeExcludedProjects(config, this.projectsToExclude.join('|'), projectsToReport);
            // If the projectsToExclude is an array with one string, we will use the regex to exclude the projects
        }
        else if (this.projectsToExclude !== undefined && typeof this.projectsToExclude !== 'string') {
            this.removeExcludedProjects(config, this.projectsToExclude.join(''), projectsToReport);
            // If the projectsToExclude is a string, we will use the regex to exclude the projects
        }
        else if (this.projectsToExclude !== undefined && typeof this.projectsToExclude === 'string') {
            this.removeExcludedProjects(config, this.projectsToExclude, projectsToReport);
            // If the projectsToExclude is not defined, we will report all the projects
        }
        else {
            for (const proj of config.projects) {
                projectsToReport.push(proj.name);
            }
        }
        projectsToReport.forEach((p, index) => {
            this.execInfo.browserName += index > 0 ? ', ' : '';
            this.execInfo.browserName += p.charAt(0).toUpperCase() + p.slice(1);
            // Set the first browser as the tested browser
            if (index === 0) {
                this.execInfo.testedBrowser = p;
                if (this.projectsToExclude?.includes(p))
                    console.log(`${(0, picocolors_1.bold)((0, picocolors_1.yellow)('⏺  '))}${(0, picocolors_1.bold)((0, picocolors_1.magenta)(`Setting for projectsToExclude conflicts with CLI argument. Will go with CLI: ${p}`))}`);
            }
        });
    }
    // biome-ignore lint/complexity/noBannedTypes: Allow for {}
    removeExcludedProjects(config, regExp, projectsToReport) {
        const excludedProjects = new RegExp(`^(${regExp})$`);
        const pr = config.projects.filter((p) => {
            if (!excludedProjects.test(p.name))
                return p;
            return;
        });
        for (const proj of pr) {
            projectsToReport.push(proj.name);
        }
    }
}
exports.default = XrayReporter;
var metadata_1 = require("./metadata");
Object.defineProperty(exports, "setXrayMetadata", { enumerable: true, get: function () { return metadata_1.setXrayMetadata; } });
__exportStar(require("./types/xray.types"), exports);
