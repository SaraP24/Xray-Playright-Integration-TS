"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToXrayJson = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const help_1 = __importDefault(require("./help"));
const metadata_1 = require("./metadata");
const cloud_types_1 = require("./types/cloud.types");
const server_types_1 = require("./types/server.types");
/**
 * Converts a map of issue keys and Playwright test results to Xray JSON. If there are multiple tests grouped under a single issue key, a
 * corresponding Xray test with iterations will be returned. Otherwise, a single Xray test will be returned without iteration data.
 *
 * Note: it does not matter where the results come from. They can be retries or they can be data-driven results for a single test. Both will
 * be converted to iterations accordingly.
 *
 * @param groupedResults the mapping of issue keys to Playwright results
 * @param options additional conversion options
 * @returns the corresponding Xray test JSON
 */
async function convertToXrayJson(groupedResults, options) {
    const xrayTests = [];
    for (const [issueKey, results] of groupedResults) {
        xrayTests.push(await getTest(issueKey, results, options));
    }
    return xrayTests;
}
exports.convertToXrayJson = convertToXrayJson;
async function getTest(issueKey, results, options) {
    const help = new help_1.default(options.jiraType);
    let xrayTest;
    if (options.jiraType === 'cloud') {
        xrayTest = {
            status: getTestStatus(results, options),
            testKey: issueKey,
            evidence: await getEvidences(results, options),
        };
    }
    else {
        xrayTest = {
            status: getTestStatus(results, options),
            testKey: issueKey,
            evidences: await getEvidences(results, options),
        };
    }
    if (results.length > 1) {
        const iterations = [];
        for (let i = 0; i < results.length; i++) {
            const result = results[i];
            const metadata = (0, metadata_1.getXrayMetadata)(result);
            const iterationParameters = Object.entries(metadata?.parameters ?? {}).map(([key, value]) => {
                return { name: key, value: value };
            });
            iterations.push({
                status: getIterationStatus(result.status, options),
                parameters: [{ name: 'iteration', value: (iterations.length + 1).toString() }, ...iterationParameters],
                steps: getSteps(result, options),
            });
        }
        xrayTest.iterations = iterations;
        xrayTest.start = help.getFormatData(new Date(Math.min(...results.map((result) => result.startTime.getTime()))));
        xrayTest.finish = help.getFormatData(new Date(Math.max(...results.map((result) => result.startTime.getTime() + result.duration))));
        xrayTest.comment = getCommentIterations(results);
    }
    else {
        const result = results[0];
        xrayTest.start = help.getFormatData(result.startTime);
        xrayTest.finish = help.getFormatData(new Date(result.startTime.getTime() + result.duration));
        xrayTest.comment = getComment(result);
        xrayTest.steps = getSteps(result, options);
    }
    return xrayTest;
}
function getTestStatus(iterations, options) {
    if (iterations.every((iteration) => iteration.status === 'failed' || iteration.status === 'timedOut')) {
        return getIterationStatus('failed', options);
    }
    if (iterations.some((iteration) => iteration.status === 'interrupted')) {
        return getIterationStatus('interrupted', options);
    }
    if (iterations.every((iteration) => iteration.status === 'skipped')) {
        return getIterationStatus('skipped', options);
    }
    // Note: flaky tests are also considered passing by default.
    return getIterationStatus('passed', options);
}
function getIterationStatus(status, options) {
    const { jiraXrayStatusMapping, jiraType } = options;
    // Use the provided 'jiraXrayStatusMapping', or select the appropriate status mapping
    // based on whether the jiraType is 'server' or 'cloud'
    const mapping = jiraXrayStatusMapping ?? (jiraType === 'server' ? server_types_1.XrayServerStatus : cloud_types_1.XrayCloudStatus);
    // If a mapping exists and the status is found in the mapping, return the corresponding value
    if (mapping && status in mapping) {
        const result = mapping[status];
        if (result === undefined) {
            throw new Error(`Status "${status}" not found for jiraType "${jiraType}".`);
        }
        return result;
    }
    // If jiraType is 'server' and the status is found in XrayServerStatus, return the value from XrayServerStatus
    if (jiraType === 'server' && status in server_types_1.XrayServerStatus) {
        return server_types_1.XrayServerStatus[status];
        // If jiraType is 'cloud' and the status is found in XrayCloudStatus, return the value from XrayCloudStatus
    }
    if (jiraType === 'cloud' && status in cloud_types_1.XrayCloudStatus) {
        return cloud_types_1.XrayCloudStatus[status];
    }
    throw new Error(`Status "${status}" not found for jiraType "${jiraType}".`);
}
function getComment(result) {
    if (result.errors.length > 0) {
        return stripAnsi(JSON.stringify(result.errors).replace(/\\\\/g, '\\'));
    }
    return undefined;
}
function getCommentIterations(iterations) {
    const errors = [];
    for (let i = 0; i < iterations.length; i++) {
        const comment = getComment(iterations[i]);
        if (comment) {
            errors.push(`Iteration ${i + 1}: ${comment}`);
        }
    }
    return errors.join('\n');
}
function getSteps(result, options) {
    const steps = [];
    for (const step of result.steps) {
        if (options.stepCategories.some((category) => category.includes(step.category))) {
            // Add Step to request
            const errorMessage = stripAnsi(step.error?.stack?.valueOf());
            const received = errorMessage ? options.receivedRegEx.exec(errorMessage) : null;
            let dataReceived = '';
            if (received?.[1] !== undefined) {
                dataReceived = received?.[1];
            }
            const xrayTestStep = {
                status: step.error !== undefined ? getIterationStatus('failed', options) : getIterationStatus('passed', options),
                comment: step.error !== undefined ? errorMessage : '',
                actualResult: dataReceived,
            };
            steps.push(xrayTestStep);
        }
    }
    return steps;
}
async function getEvidences(results, options) {
    const evidences = [];
    if (results.length > 1) {
        for (let i = 0; i < results.length; i++) {
            const result = results[i];
            // Evidence can only be added to iteration steps, not the iterations themselves.
            // But we can still attach iteration evidence to the test itself.
            for (const evidence of await getEvidence(result, options, `iteration_${i + 1}_`)) {
                evidences.push(evidence);
            }
        }
    }
    else {
        for (const evidence of await getEvidence(results[0], options)) {
            evidences.push(evidence);
        }
    }
    return evidences;
}
async function getEvidence(result, options, prefix) {
    // Get evidences from test results (video, images, text)
    const evidences = [];
    if (result.attachments.length > 0) {
        await Promise.all(result.attachments.map(async (attach) => {
            if (attach.name.includes('screenshot') && options.uploadScreenshot) {
                await addEvidence(attach, evidences, prefix);
            }
            if (attach.name.includes('trace') && options.uploadTrace) {
                await addEvidence(attach, evidences, prefix);
            }
            if (attach.name.includes('video') && options.uploadVideo) {
                await addEvidence(attach, evidences, prefix);
            }
        }));
    }
    return evidences;
}
function stripAnsi(step) {
    if (step === undefined) {
        return '';
    }
    const ST = '(?:\\u0007|\\u001B\\u005C|\\u009C)';
    const pattern = [
        `[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`,
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))',
    ].join('|');
    let errorMessage = step.replace(new RegExp(pattern, 'g'), '');
    errorMessage = errorMessage.replace(/(\\u001b)(8|7|H|>|\[(\?\d+(h|l)|[0-2]?(K|J)|\d*(A|B|C|D\D|E|F|G|g|i|m|n|S|s|T|u)|1000D\d+|\d*;\d*(f|H|r|m)|\d+;\d+;\d+m))/g, '');
    return errorMessage;
}
async function addEvidence(attach, evidences, prefix) {
    if (!attach.path) {
        throw new Error('Attachment path is undefined');
    }
    const filename = `${prefix ?? ''}${node_path_1.default.basename(attach.path)}`;
    const attachData = node_fs_1.default.readFileSync(attach.path, { encoding: 'base64' });
    const evid = {
        data: attachData,
        filename: filename,
        contentType: attach.contentType,
    };
    evidences.push(evid);
}
